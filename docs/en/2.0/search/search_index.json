{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Appium Documentation This is the Appium documentation. TODO","title":"Home"},{"location":"#appium-documentation","text":"This is the Appium documentation. TODO","title":"Appium Documentation"},{"location":"cli/","text":"TODO","title":"CLI Intro"},{"location":"cli/args/","text":"TODO","title":"Server CLI Args"},{"location":"cli/extensions/","text":"TODO","title":"The Extension CLI"},{"location":"contributing/","text":"TODO","title":"Contributing"},{"location":"ecosystem/","text":"Appium has an ecosystem of related software and tools. In this guide we'll discuss important officially-supported and community-supported projects. Appium Inspector Appium has a graphical client which can be used to manually perform Appium commands, inspect app hierarchies, view screenshots, and more. It's very useful for Appium test development. You can learn more about the inspector here: Appium Inspector Drivers You can't use Appium without at least one driver! Here are the drivers that are officially recognized by Appium. Click on the link for each driver to see the specific installation instructions and documentation for that driver. To learn more about what drivers are and how they work, check out the Driver Intro Driver Installation Key Platform(s) Mode(s) Support XCUITest xcuitest iOS Native, Hybrid, Web Appium Team UiAutomator2 uiautomator2 Android Native, Hybrid, Web Appium Team Espresso espresso Android Native Appium Team Mac2 mac2 macOS Native Appium Team Safari safari macOS, iOS Web Appium Team Gecko safari macOS, Windows, Linux, Android Web Appium Team Windows windows Windows Native Community / Microsoft Flutter flutter iOS, Android Native Community Tizen tizen Android Native Community / Samsung Youi youiengine iOS, Android, macOS, Linux, tvOS Native Community / You.i And of course, you can install any other drivers you find out there by using the Appium driver CLI. Clients You need a clients to write and run Appium scripts. To learn more about clients, read our Client Intro . Here is the list of known Appium clients. You'll want to become very familiar with your client documentation (as well as the documentation of any Selenium client that the Appium client depends on) since that is what you will use as your primary interface to Appium. Client Language Support Appium Java client Java Appium Team Appium Python client Python Appium Team Appium Ruby client Ruby Appium Team WebDriverIO Node.js Community Appium .NET client C# Appium Team* RobotFramework DSL Community Warning Currently, the .NET client has a low level of maintenance/support. Expect bugs and incompatibility. We're looking for help here, so please reach out if you know .NET! In general, any W3C WebDriver spec-compatible client will also integrate well with Appium, though some Appium-specific commands may not be implemented in other clients.","title":"The Appium Ecosystem"},{"location":"ecosystem/#appium-inspector","text":"Appium has a graphical client which can be used to manually perform Appium commands, inspect app hierarchies, view screenshots, and more. It's very useful for Appium test development. You can learn more about the inspector here: Appium Inspector","title":"Appium Inspector"},{"location":"ecosystem/#drivers","text":"You can't use Appium without at least one driver! Here are the drivers that are officially recognized by Appium. Click on the link for each driver to see the specific installation instructions and documentation for that driver. To learn more about what drivers are and how they work, check out the Driver Intro Driver Installation Key Platform(s) Mode(s) Support XCUITest xcuitest iOS Native, Hybrid, Web Appium Team UiAutomator2 uiautomator2 Android Native, Hybrid, Web Appium Team Espresso espresso Android Native Appium Team Mac2 mac2 macOS Native Appium Team Safari safari macOS, iOS Web Appium Team Gecko safari macOS, Windows, Linux, Android Web Appium Team Windows windows Windows Native Community / Microsoft Flutter flutter iOS, Android Native Community Tizen tizen Android Native Community / Samsung Youi youiengine iOS, Android, macOS, Linux, tvOS Native Community / You.i And of course, you can install any other drivers you find out there by using the Appium driver CLI.","title":"Drivers"},{"location":"ecosystem/#clients","text":"You need a clients to write and run Appium scripts. To learn more about clients, read our Client Intro . Here is the list of known Appium clients. You'll want to become very familiar with your client documentation (as well as the documentation of any Selenium client that the Appium client depends on) since that is what you will use as your primary interface to Appium. Client Language Support Appium Java client Java Appium Team Appium Python client Python Appium Team Appium Ruby client Ruby Appium Team WebDriverIO Node.js Community Appium .NET client C# Appium Team* RobotFramework DSL Community Warning Currently, the .NET client has a low level of maintenance/support. Expect bugs and incompatibility. We're looking for help here, so please reach out if you know .NET! In general, any W3C WebDriver spec-compatible client will also integrate well with Appium, though some Appium-specific commands may not be implemented in other clients.","title":"Clients"},{"location":"ecosystem/build-docs/","text":"TODO","title":"Building Docs for Appium Extensions"},{"location":"ecosystem/build-drivers/","text":"TODO","title":"Building Appium Drivers"},{"location":"ecosystem/build-plugins/","text":"TODO","title":"Building Appium Plugins"},{"location":"guides/caps/","text":"TODO","title":"Capabilities"},{"location":"guides/config/","text":"TODO","title":"The Appium Config File"},{"location":"guides/context/","text":"TODO","title":"The Context API"},{"location":"guides/event-timing/","text":"TODO","title":"The Event Timing API"},{"location":"guides/grid/","text":"TODO","title":"Appium and Selenium Grid"},{"location":"guides/log-filters/","text":"TODO","title":"Log Filtering"},{"location":"guides/managing-exts/","text":"TODO","title":"Managing Appium Drivers and Plugins"},{"location":"guides/migrating-1-to-2/","text":"TODO","title":"Migrating from Appium 1.x to Appium 2.x"},{"location":"guides/security/","text":"TODO","title":"Appium Server Security"},{"location":"intro/","text":"TODO","title":"Intro to Appium"},{"location":"intro/clients/","text":"TODO","title":"Intro to Appium Clients"},{"location":"intro/drivers/","text":"TODO","title":"Intro to Appium Drivers"},{"location":"intro/history/","text":"Appium has been around in one form or another since 2012. It's been under the direction of various individuals and organizations, and it's even been implemented in 3 different programming languages! Welcome to more than you ever wanted to know about how Appium got to be what is it today... Early Inspiration Dan Cuellar was the Test Manager at Zoosk in 2011, when he encountered a problem. The length of the test passes on the iOS product was getting out of hand. Less testing was an option, but would come with additional risk, especially with it taking several days to get patches through the iOS App Store Review process. He thought back to his days working on websites and realized automation was the answer. Dan surveyed the existing landscape of tools, only to find that all of them hand major drawbacks. The tool supplied by Apple, UIAutomation, required tests to be written in JavaScript, and did not allow for real-time debugging or interpretation. It also had to be executed inside the Xcode profiling tool, Instruments. Other 3rd-party tools used private APIs and required SDKs and HTTP Servers to be embedded into the application. This seemed highly undesirable. Unsatisfied with the existing options, Dan asked his manager for some additional time to see if he could find a better way. He spent 2 weeks poking and prodding around to see if there was a way to use approved Apple technologies to automate an iOS application. The first implementation he tried used AppleScript to send messages to Mac UI elements using the OS X accessibility APIs. This worked to some degree, but would never work on real devices, not to mention other drawbacks. So he thought, what if I could get the UIAutomation framework to run in real time like an interpreter? He looked into it and he determined that all he would need to do is find a way to receive, execute, and reply to commands from within a UIAutomation javascript program. Using the utility Apple provided for executing shell commands he was able to cat sequentially ordered text files to receive commands, eval() the output to execute them, and write them back to disk with python . He then prepared code in C# that implemented the Selenium-style syntax to write the sequentially ordered javascript commands. iOSAuto is born. Selenium Conference 2012 Dan was selected to speak at Selenium Conference 2012 in London about an entirely different topic. As part of his presentation, he showed off iOS Automation using Selenium syntax to demonstrate writing platform-agnostic tests that use separate platform-specific page objects with a common interface. To his surprise, the cool test architecture would take a backseat to the spectacle of iOS tests running like WebDriver tests. Several people suggested that he give a lightning talk later in the conference to explain exactly how it worked. On the second day of the conference, Dan stepped up on stage to give the lightning talk. Jason Huggins, co-creator of Selenium, moderated the lightning talks. Dan experienced technical difficulties getting his presentation to load, and Jason nearly had to move on to the next lightning talk. At the last moment, the screen turned on and Dan jumped into his presentation. He explained the details of his implementation and how it worked, begged for contributors, and in five minutes it was over. The crowd applauded politely, and he left the stage. The Phone Rings Four months after the Selenium Conference, Jason called Dan. Jason had been working on iOS testing support for a client at Sauce Labs. Jason remembered Dan's lightning talk and thought the project might be useful to Jason's work, but Dan's source code was not public. Jason asked Dan to meet up. Later that week, Dan met Jason in a bar in San Francisco and showed him the source code for iOS Auto. A long-time open source advocate, Jason encouraged Dan to release his code under an open source license. In August, Dan released the source code on GitHub in C#. Jason encouraged Dan to change the language to make the project more appealing to potential contributors. Dan uploaded a new version in Python . In September, Jason added a web server and began to implement the WebDriver wire protocol over HTTP, making iOS Auto scriptable from any Selenium WebDriver client library in any language. The Mobile Testing Summit Jason decided that the project should be presented at the Mobile Testing Summit in November, but suggested that the project get a new name first. Many ideas were thrown out and they settled on AppleCart. A day later, while he was perusing some of Apple's guidance on copyright and trademarks, Jason noticed that under the section of examples for names Apple would defend its trademarks against, the first example was \"AppleCart\". He called Dan and informed him of the situation, and they brainstormed for a bit before Jason hit the jackpot. Appium... Selenium for Apps. Sauce Labs and Node.js In January 2013, not long after the Mobile Testing Summit, Sauce Labs decided to fully back Appium and provide more developer power. A task force was created to evaluate the current state and how best to move forward with the project. The team, which included Jonathan Lipps (the current project lead), decided that Appium needed a rebirth, and ultimately settled on Node.js as the framework to use. Node is well-known as a fast and efficient web server backend, and at the end of the day, Appium is just a highly-specialized web server. It was also decided that JavaScript as a language was accessible enough that Appium would be able to grow into a larger community of open-source developers with JavaScript than the other options on the table. In just a few days, the team leveraged the existing work on Appium and had a new version of Appium with as much functionality as the previous Python version. The foundation had been laid for Appium's basic architecture, and we have been successfully building on it since. A few weeks into this sprint, Jonathan Lipps was formally designated project lead and he began to strategize how to get more people from the community involved with Appium's development. Appium Around the World Ultimately, Jonathan decided that getting Appium in front of as many developers at conferences and meetups was the best way to attract users and contributions. Appium in its new incarnation was debuted at the Google Test Automation Conference 2013 . Later in 2013, Appium was presented at conferences and meetups all around the US, as well as in England, Poland, Portugal, and Australia. Notably, Jonathan had Appium perform as instruments in a band and Dan Cuellar put together a fun Appium video montage for Selenium Conference. But during all these presentations and conferences, the project continued to develop. Early in 2013 we released Android and Selendroid support, making Appium the first truly cross-platform automation framework. The project also continued to attract users and contributors, and by the end of 2013, we'd already had well over 1,000 commits. The Road to Appium 1.0 Appium began to grow and mature significantly. In May 2014, we released Appium 1.0, which stood as a milestone in Appium's development. Appium was given various awards and became the most popular open-source cross-platform mobile automation framework. Stability improved, bugs were prioritized and fixed, and features added. Sauce Labs increased the number of developers it donated to working on Appium, but the entire community stayed involved in guiding the project and contributing to it, and project governance continued to happen in the open, on public mailing lists and GitHub's issue tracker. The Appium Umbrella Broadens Eventually, it became clear that the Appium codebase was not optimized for a large team of distributed, sometime contributors. We took the opportunity as a committer team to rewrite Appium from the ground up, using a more modern version of the JavaScript language, and redoing Appium's architecture so that it was easy for users or third-party developers to build their own Appium \"drivers\". We wanted for it to be easier for new contributors to get ramped up on the Appium codebase, and to see support for new platforms added to Appium by groups other than the core team. That vision has begun to be fulfilled, with groups like Microsoft and Youi.tv adding drivers to Appium for Windows desktop app automation and Youi.tv app automation, respectively. Who knows what platforms will be added next? Appium To The People In late 2016, Sauce Labs donated Appium as a project to the JS Foundation , in order to cement for the world Sauce's commitment that Appium remains open source. The JS Foundation is a non-profit open source stewardship organization which takes responsibility for holding the copyright for open source projects, as well as ensuring they have a long and successful tenure in the community. As a result of our move to a non-profit foundation, we hope that the door will open even more widely for new contributors, either as individuals or representing one of the many companies which now have an interest in seeing Appium move forward. Eventually, the JS Foundation merged into the OpenJS Foundation , and Appium is currently an Impact Project in the foundation. Appium 2.0 Appium 2.0 was released in 2022, with a new focus on Appium as an ecosystem rather than a singular project. Drivers and plugins can be developed and shared by anyone, opening up a world of possibilities for automation-related development for platforms far beyond iOS and Android.","title":"Appium Project History"},{"location":"intro/history/#early-inspiration","text":"Dan Cuellar was the Test Manager at Zoosk in 2011, when he encountered a problem. The length of the test passes on the iOS product was getting out of hand. Less testing was an option, but would come with additional risk, especially with it taking several days to get patches through the iOS App Store Review process. He thought back to his days working on websites and realized automation was the answer. Dan surveyed the existing landscape of tools, only to find that all of them hand major drawbacks. The tool supplied by Apple, UIAutomation, required tests to be written in JavaScript, and did not allow for real-time debugging or interpretation. It also had to be executed inside the Xcode profiling tool, Instruments. Other 3rd-party tools used private APIs and required SDKs and HTTP Servers to be embedded into the application. This seemed highly undesirable. Unsatisfied with the existing options, Dan asked his manager for some additional time to see if he could find a better way. He spent 2 weeks poking and prodding around to see if there was a way to use approved Apple technologies to automate an iOS application. The first implementation he tried used AppleScript to send messages to Mac UI elements using the OS X accessibility APIs. This worked to some degree, but would never work on real devices, not to mention other drawbacks. So he thought, what if I could get the UIAutomation framework to run in real time like an interpreter? He looked into it and he determined that all he would need to do is find a way to receive, execute, and reply to commands from within a UIAutomation javascript program. Using the utility Apple provided for executing shell commands he was able to cat sequentially ordered text files to receive commands, eval() the output to execute them, and write them back to disk with python . He then prepared code in C# that implemented the Selenium-style syntax to write the sequentially ordered javascript commands. iOSAuto is born.","title":"Early Inspiration"},{"location":"intro/history/#selenium-conference-2012","text":"Dan was selected to speak at Selenium Conference 2012 in London about an entirely different topic. As part of his presentation, he showed off iOS Automation using Selenium syntax to demonstrate writing platform-agnostic tests that use separate platform-specific page objects with a common interface. To his surprise, the cool test architecture would take a backseat to the spectacle of iOS tests running like WebDriver tests. Several people suggested that he give a lightning talk later in the conference to explain exactly how it worked. On the second day of the conference, Dan stepped up on stage to give the lightning talk. Jason Huggins, co-creator of Selenium, moderated the lightning talks. Dan experienced technical difficulties getting his presentation to load, and Jason nearly had to move on to the next lightning talk. At the last moment, the screen turned on and Dan jumped into his presentation. He explained the details of his implementation and how it worked, begged for contributors, and in five minutes it was over. The crowd applauded politely, and he left the stage.","title":"Selenium Conference 2012"},{"location":"intro/history/#the-phone-rings","text":"Four months after the Selenium Conference, Jason called Dan. Jason had been working on iOS testing support for a client at Sauce Labs. Jason remembered Dan's lightning talk and thought the project might be useful to Jason's work, but Dan's source code was not public. Jason asked Dan to meet up. Later that week, Dan met Jason in a bar in San Francisco and showed him the source code for iOS Auto. A long-time open source advocate, Jason encouraged Dan to release his code under an open source license. In August, Dan released the source code on GitHub in C#. Jason encouraged Dan to change the language to make the project more appealing to potential contributors. Dan uploaded a new version in Python . In September, Jason added a web server and began to implement the WebDriver wire protocol over HTTP, making iOS Auto scriptable from any Selenium WebDriver client library in any language.","title":"The Phone Rings"},{"location":"intro/history/#the-mobile-testing-summit","text":"Jason decided that the project should be presented at the Mobile Testing Summit in November, but suggested that the project get a new name first. Many ideas were thrown out and they settled on AppleCart. A day later, while he was perusing some of Apple's guidance on copyright and trademarks, Jason noticed that under the section of examples for names Apple would defend its trademarks against, the first example was \"AppleCart\". He called Dan and informed him of the situation, and they brainstormed for a bit before Jason hit the jackpot. Appium... Selenium for Apps.","title":"The Mobile Testing Summit"},{"location":"intro/history/#sauce-labs-and-nodejs","text":"In January 2013, not long after the Mobile Testing Summit, Sauce Labs decided to fully back Appium and provide more developer power. A task force was created to evaluate the current state and how best to move forward with the project. The team, which included Jonathan Lipps (the current project lead), decided that Appium needed a rebirth, and ultimately settled on Node.js as the framework to use. Node is well-known as a fast and efficient web server backend, and at the end of the day, Appium is just a highly-specialized web server. It was also decided that JavaScript as a language was accessible enough that Appium would be able to grow into a larger community of open-source developers with JavaScript than the other options on the table. In just a few days, the team leveraged the existing work on Appium and had a new version of Appium with as much functionality as the previous Python version. The foundation had been laid for Appium's basic architecture, and we have been successfully building on it since. A few weeks into this sprint, Jonathan Lipps was formally designated project lead and he began to strategize how to get more people from the community involved with Appium's development.","title":"Sauce Labs and Node.js"},{"location":"intro/history/#appium-around-the-world","text":"Ultimately, Jonathan decided that getting Appium in front of as many developers at conferences and meetups was the best way to attract users and contributions. Appium in its new incarnation was debuted at the Google Test Automation Conference 2013 . Later in 2013, Appium was presented at conferences and meetups all around the US, as well as in England, Poland, Portugal, and Australia. Notably, Jonathan had Appium perform as instruments in a band and Dan Cuellar put together a fun Appium video montage for Selenium Conference. But during all these presentations and conferences, the project continued to develop. Early in 2013 we released Android and Selendroid support, making Appium the first truly cross-platform automation framework. The project also continued to attract users and contributors, and by the end of 2013, we'd already had well over 1,000 commits.","title":"Appium Around the World"},{"location":"intro/history/#the-road-to-appium-10","text":"Appium began to grow and mature significantly. In May 2014, we released Appium 1.0, which stood as a milestone in Appium's development. Appium was given various awards and became the most popular open-source cross-platform mobile automation framework. Stability improved, bugs were prioritized and fixed, and features added. Sauce Labs increased the number of developers it donated to working on Appium, but the entire community stayed involved in guiding the project and contributing to it, and project governance continued to happen in the open, on public mailing lists and GitHub's issue tracker.","title":"The Road to Appium 1.0"},{"location":"intro/history/#the-appium-umbrella-broadens","text":"Eventually, it became clear that the Appium codebase was not optimized for a large team of distributed, sometime contributors. We took the opportunity as a committer team to rewrite Appium from the ground up, using a more modern version of the JavaScript language, and redoing Appium's architecture so that it was easy for users or third-party developers to build their own Appium \"drivers\". We wanted for it to be easier for new contributors to get ramped up on the Appium codebase, and to see support for new platforms added to Appium by groups other than the core team. That vision has begun to be fulfilled, with groups like Microsoft and Youi.tv adding drivers to Appium for Windows desktop app automation and Youi.tv app automation, respectively. Who knows what platforms will be added next?","title":"The Appium Umbrella Broadens"},{"location":"intro/history/#appium-to-the-people","text":"In late 2016, Sauce Labs donated Appium as a project to the JS Foundation , in order to cement for the world Sauce's commitment that Appium remains open source. The JS Foundation is a non-profit open source stewardship organization which takes responsibility for holding the copyright for open source projects, as well as ensuring they have a long and successful tenure in the community. As a result of our move to a non-profit foundation, we hope that the door will open even more widely for new contributors, either as individuals or representing one of the many companies which now have an interest in seeing Appium move forward. Eventually, the JS Foundation merged into the OpenJS Foundation , and Appium is currently an Impact Project in the foundation.","title":"Appium To The People"},{"location":"intro/history/#appium-20","text":"Appium 2.0 was released in 2022, with a new focus on Appium as an ecosystem rather than a singular project. Drivers and plugins can be developed and shared by anyone, opening up a world of possibilities for automation-related development for platforms far beyond iOS and Android.","title":"Appium 2.0"},{"location":"intro/requirements/","text":"The basic requirements for the Appium server are: A macOS, Linux, or Windows operating system Node.js version >= 14 NPM version >= 8 (NPM is usually bundled with Node.js, but can be upgraded independently) By itself, Appium is relatively lightweight and doesn't have significant disk space or RAM requirements. It can even be run in resource-constrained environments like Raspberry Pi, so long as Node.js is available. To use Appium to automate a particular platform, please refer to the documentation of the Appium driver(s) for that platform for additional dependencies. It is almost universally the case that Appium drivers for a given platform will require the developer toolchain and SDKs for that platform to be available.","title":"Appium Requirements"},{"location":"quickstart/","text":"Let's get up and running with Appium! To successfully use this quickstart, it's recommended that you first have read the Introduction , so that you understand the concepts involved in running Appium and writing Appium scripts. The basic plan for this quickstart is as follows: Install Appium Install an Appium driver and its dependencies (we'll be using the UiAutomator2 driver for these examples) Install an Appium client library in your language or choice (this guide contains options for JavaScript, Python, and Java, though Appium clients also exist in other language). Write and run a simple Appium automation script using a sample application Requirements Before getting started, make sure your system satisfies the requirements for running the Appium server. Additional requirements will be discussed in conjunction with installing the UiAutomator2 driver. The guide also assumes you're basic command line proficiency on your platform, for example being able to run commands, set and persist environment variables, etc... Now you're ready to get started! So head on over to Installing Appium .","title":"Quickstart Intro"},{"location":"quickstart/#requirements","text":"Before getting started, make sure your system satisfies the requirements for running the Appium server. Additional requirements will be discussed in conjunction with installing the UiAutomator2 driver. The guide also assumes you're basic command line proficiency on your platform, for example being able to run commands, set and persist environment variables, etc... Now you're ready to get started! So head on over to Installing Appium .","title":"Requirements"},{"location":"quickstart/install/","text":"Installing Appium is as easy as running a single NPM command: npm i -g appium@next Note Currently, you must use appium@next instead of just appium . Once Appium 2.0 has been officially published, you can simply use appium . This command installs Appium globally on your system so that you can access it from the command line simply by running the appium command. Go ahead and run it now: appium You should see some output that starts with a line like this: [Appium] Welcome to Appium v2.0.0 That's it! If you get this kind of output, the Appium server is up and running. Go ahead and quit it (CTRL-C) and move on to the next step, where we'll install a driver for automating Android apps.","title":"Install Appium"},{"location":"quickstart/next-steps/","text":"Now that you've successfully set up your system for Android automation and run a simple test, you'll want to continue exploring this documentation. In particular, these are good guides and reference materials especially for beginners: Managing Appium Drivers and Plugins Capabilities The list of available Drivers and Plugins You'll also find that the Appium Inspector is an indispensable tool for use in Appium test-writing, as it enables visual inspection of apps and helps you to discover element locators for use in your test scripts. You might also take advantage of one of the many online Appium courses available to you. Good luck and have fun!","title":"Next Steps"},{"location":"quickstart/test-java/","text":"TODO","title":"Write a Test (Java)"},{"location":"quickstart/test-js/","text":"To write an Appium test in JavaScript (Node.js), we need to choose an Appium-compatible client library. The best-maintained library and the one the Appium team recommends using is WebdriverIO , so let's use that. Since we already have Appium installed we know our Node and NPM requirements are already satisfied. So just create a new project directory somewhere on your computer and then initialize a new Node.js project in it: npm init It doesn't really matter what you put in the prompts, just so long as you end up with a valid package.json . Now, install the webdriverio package via NPM: npm i --save-dev webdriverio Once this is done, your package.json file should include a section like the following: package.json { \"devDependencies\" : { \"webdriverio\" : \"^7.19.3\" } } Now it's time to type up the test itself. Create a new file called test.js with the following contents: test.js const { remote } = require ( 'webdriverio' ) const capabilities = { 'platformName' : 'Android' , 'appium:automationName' : 'UiAutomator2' , 'appium:deviceName' : 'Android' , 'appium:appPackage' : 'com.android.settings' , 'appium:appActivity' : '.Settings' , } const wdOpts = { host : process . env . APPIUM_HOST || 'localhost' , port : parseInt ( process . env . APPIUM_PORT , 10 ) || 4723 , logLevel : 'info' , capabilities , } async function runTest () { const driver = await remote ( wdOpts ) try { const batteryItem = await driver . $ ( '//*[@text=\"Battery\"]' ) await batteryItem . click () } finally { await driver . pause ( 1000 ) await driver . deleteSession () } } runTest (). catch ( console . error ) Note It's not within the scope of this guide to give a complete run-down on the WebdriverIO client library or everything that's happening here, so we'll leave the code itself unexplained in detail for now. You may want to read up particularly on Appium Capabilities in addition to familiarizing yourself with the excellent WebdriverIO documentation for a fuller explanation of the various API commands you see and what their purpose is. Basically, this code is doing the following: Defining a set of \"Capabilities\" (parameters) to send to the Appium server so Appium knows what kind of thing you want to automate. Starting an Appium session on the built-in Android settings app. Finding the \"Battery\" list item and clicking it. Pausing for a moment purely for visual effect. Ending the Appium session. That's it! Let's give it a try. Before you run the test, make sure that you have an Appium server running in another terminal session, otherwise you'll get an error about not being able to connect to one. Then, you can execute the script: node test.js If all goes well, you'll see the Settings app open up and navigate to the \"Battery\" view before the app closes again. Congratulations, you've started your Appium journey! Read on for some next steps to explore.","title":"Write a Test (JS)"},{"location":"quickstart/test-py/","text":"TODO","title":"Write a Test (Python)"},{"location":"quickstart/uiauto2-driver/","text":"You can't do much with Appium unless you have a driver , which is an interface that allows Appium to automate a particular platform. For this quickstart guide, we're going to be automating an app on the Android platform, because the system requirements for Android automation via Appium are the same as for Appium itself (whereas the iOS driver, for example, requires you to be using macOS). The driver we're going to use is called the UiAutomator2 Driver . It's worth visiting that driver's documentation and bookmarking it, because it will be an invaluable reference down the line. Set up Android automation requirements According to the driver, in addition to a working Appium server, we also need to do the following: Download Android SDK platform tools . You will probably want to download Android Studio and manage the SDK tools from within it for the easiest experience. Set an environment variable pointing to the directory on disk where the Android tools are installed. You can usually find the path to this directory in the Android Studio SDK manager. It will contain the platform-tools and other directories. We need to define and persist the environment variable as ANDROID_HOME (or alternatively ANDROID_SDK_ROOT ). Use the Android SDK manager to download whichever Android platform we want to automate (for example, API level 30) Install the Java JDK (for the most recent Android API levels, JDK 9 is required, otherwise JDK 8 is required). It's easiest to use the OpenJDK packages . Make sure you get the JDK and not the JRE. When the JDK is installed, you'll need to find the path to the JDK home directory as it was installed on your system. This will be the directory that contains the bin , include , and other directories. The path must be persisted as an environment variable named JAVA_HOME , so that Appium can find the appropriate Java tooling that is required to work with the Android platform. Use Android Studio to create and launch an Android Virtual Device (an AVD, otherwise known as an emulator). You may need to download the system images for the API level of the emulator you want to create. Using the AVD creation wizard in Android Studio is generally the easiest way to do all of this. Note You can also use a physical Android device, so long as it is configured for debugging and development With the emulator or device connected, you can run adb devices (via the binary located at $ANDROID_HOME/platform-tools/adb ) to verify that your device shows up as connected. Once your device shows up as connected in ADB, and you've verified that the environment variables are set up correctly in the terminal context where you are going to run Appium, you should be good to go! If you ran into problems with any of these steps, refer to the driver documentation, or the various Android or Java documentation sites as necessary. Also, congratulations: whether or not you intended to, you now have the Android developer toolchain set up on your system, so you can get busy making Android apps if you want! Install the driver itself Since the UiAutomator2 driver is maintained by the core Appium team, it has an 'official' driver name that you can use to install it easily via the Appium Extension CLI : appium driver install uiautomator2 It should produce output that looks something like: Attempting to find and install driver 'uiautomator2' \u2714 Installing 'uiautomator2' using NPM install spec 'appium-uiautomator2-driver' Driver uiautomator2@2.0.5 successfully installed - automationName: UiAutomator2 - platformNames: [\"Android\"] Running this command will locate and install the latest version of the UiAutomator2 driver, making it available for automation. Note that when it is installed it tells you what platforms it is valid for (in this case, Android ), and what automation name (the appium:automationName capability ) must be used to select this driver for use during an Appium session (in this case, UiAutomator2 ). Note In this quickstart we have used the Extension CLI to install the UiAutomator2 driver, but if you are incorporating Appium into a Node.js project, you might prefer to use NPM to manage Appium and its connected drivers. To learn more about this technique, visit the guide on managing Appium extensions . Now, start the Appium server again (run appium ), and you should see that the newly-installed driver is listed as available: [Appium] Available drivers: [Appium] - uiautomator2@2.0.5 (automationName 'UiAutomator2') With the Android setup complete and the UiAutomator2 driver installed, you're ready to write your first test! So pick the language you're most comfortable with under the quickstart menu and give it a shot.","title":"Install the UiAutomator2 Driver"},{"location":"quickstart/uiauto2-driver/#set-up-android-automation-requirements","text":"According to the driver, in addition to a working Appium server, we also need to do the following: Download Android SDK platform tools . You will probably want to download Android Studio and manage the SDK tools from within it for the easiest experience. Set an environment variable pointing to the directory on disk where the Android tools are installed. You can usually find the path to this directory in the Android Studio SDK manager. It will contain the platform-tools and other directories. We need to define and persist the environment variable as ANDROID_HOME (or alternatively ANDROID_SDK_ROOT ). Use the Android SDK manager to download whichever Android platform we want to automate (for example, API level 30) Install the Java JDK (for the most recent Android API levels, JDK 9 is required, otherwise JDK 8 is required). It's easiest to use the OpenJDK packages . Make sure you get the JDK and not the JRE. When the JDK is installed, you'll need to find the path to the JDK home directory as it was installed on your system. This will be the directory that contains the bin , include , and other directories. The path must be persisted as an environment variable named JAVA_HOME , so that Appium can find the appropriate Java tooling that is required to work with the Android platform. Use Android Studio to create and launch an Android Virtual Device (an AVD, otherwise known as an emulator). You may need to download the system images for the API level of the emulator you want to create. Using the AVD creation wizard in Android Studio is generally the easiest way to do all of this. Note You can also use a physical Android device, so long as it is configured for debugging and development With the emulator or device connected, you can run adb devices (via the binary located at $ANDROID_HOME/platform-tools/adb ) to verify that your device shows up as connected. Once your device shows up as connected in ADB, and you've verified that the environment variables are set up correctly in the terminal context where you are going to run Appium, you should be good to go! If you ran into problems with any of these steps, refer to the driver documentation, or the various Android or Java documentation sites as necessary. Also, congratulations: whether or not you intended to, you now have the Android developer toolchain set up on your system, so you can get busy making Android apps if you want!","title":"Set up Android automation requirements"},{"location":"quickstart/uiauto2-driver/#install-the-driver-itself","text":"Since the UiAutomator2 driver is maintained by the core Appium team, it has an 'official' driver name that you can use to install it easily via the Appium Extension CLI : appium driver install uiautomator2 It should produce output that looks something like: Attempting to find and install driver 'uiautomator2' \u2714 Installing 'uiautomator2' using NPM install spec 'appium-uiautomator2-driver' Driver uiautomator2@2.0.5 successfully installed - automationName: UiAutomator2 - platformNames: [\"Android\"] Running this command will locate and install the latest version of the UiAutomator2 driver, making it available for automation. Note that when it is installed it tells you what platforms it is valid for (in this case, Android ), and what automation name (the appium:automationName capability ) must be used to select this driver for use during an Appium session (in this case, UiAutomator2 ). Note In this quickstart we have used the Extension CLI to install the UiAutomator2 driver, but if you are incorporating Appium into a Node.js project, you might prefer to use NPM to manage Appium and its connected drivers. To learn more about this technique, visit the guide on managing Appium extensions . Now, start the Appium server again (run appium ), and you should see that the newly-installed driver is listed as available: [Appium] Available drivers: [Appium] - uiautomator2@2.0.5 (automationName 'UiAutomator2') With the Android setup complete and the UiAutomator2 driver installed, you're ready to write your first test! So pick the language you're most comfortable with under the quickstart menu and give it a shot.","title":"Install the driver itself"}]}